# JS设计模式——观察者模式

观察者模式( 又叫发布者-订阅者模式 )应该是最常用的模式之一. 在很多语言里都得到大量应用. 包括我们平时接触的dom事件. 也是js和dom之间实现的一种观察者模式.

```
div.onclick = function click (){
  alert ("click")
}
```  
只要订阅了div的click事件. 当点击div的时候, function click就会被触发.   

## Observer模式的角色  
比如:宝宝(被观察者)的心情变化要通知妈妈爸爸(观察者)

### Subject（被观察者）  
被观察的对象。当需要被观察的状态发生变化时，需要通知队列中所有观察者对象。
被观察者有两个核心方法
`setState`当宝宝的心情变化的要通知数组的观察者
`attach` 存储观察者
```
class Subject{
    constructor(name){
        this.name = name;
        this.observers = []; //存储观察者
        this.state = '心情很美丽'
    }
    setState(newsate){ //状态更变,通知观察者
        this.state = newsate; 
        this.observers.forEach(o=>o.update(newsate))
    }
    // 被观察者要提供一个接受观察者的方法(存储观察者)
    attach(Observer){
        this.observers.push(Observer); //存放所有观察者
    }
}
```

### Observer（观察者）  
接口或抽象类。当Subject的状态发生变化时，Observer对象将通过一个callback函数得到通知。
观察者的核心方法就是接受观察者发来的状态
```
class Observer {
    constructor(name){
        this.name = name;
    }
    update(newsate){ //用来通知所有的观察者状态更新了
        console.log(this.name+'说:宝宝'+newsate)
    }
}

```

### 下面是对观察者模式的实现代码
```

class Subject{
    constructor(name){
        this.name = name;
        this.observers = []; //存储观察者
        this.state = '心情很美丽'
    }
    setState(newsate){ //状态更变,通知观察者
        this.state = newsate; 
        this.observers.forEach(o=>o.update(newsate))
    }
    // 被观察者要提供一个接受观察者的方法(存储观察者)
    attach(Observer){
        this.observers.push(Observer); //存放所有观察者
    }
}

class Observer {
    constructor(name){
        this.name = name;
    }
    update(newsate){ //用来通知所有的观察者状态更新了
        console.log(this.name+'说:宝宝'+newsate)
    }
}

let sub = new Subject('小宝宝');

let o1 = new Observer('爸爸');
let o2 = new Observer('妈妈');

//宝宝要接受观察者
sub.attach(o1);
sub.attach(o2);

sub.setState('心情不好了');
```



